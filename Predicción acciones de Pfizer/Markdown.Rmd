---
title: "Precio de las acciones de Pfizer"
author: "Andrés Dala"
date: "26/11/2021"
output:
  html_document: 
    toc: yes
    toc_float: true
    smooth_scroll : TRUE
    theme: cerulean
    df_print: default
  pdf_document: default
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = "center")
```

# Introducción

El **precio de apertura** es el precio al que un valor cotiza por primera vez tras la apertura de una bolsa en un día de negociación; por ejemplo, la Bolsa de Valores de Nueva York (NYSE) abre exactamente a las 9:30 a.m., hora del Este. El precio de la primera operación de cualquier acción cotizada es su precio de apertura diario. El precio de apertura es un marcador importante para la actividad comercial de ese día, particularmente para aquellos interesados en medir los resultados a corto plazo, como los operadores diarios.
El **precio de cierre** generalmente se refiere al último precio al que se negocia una acción durante una sesión de negociación regular. Para muchos mercados de EE. UU. las sesiones comerciales regulares se realizan de 9:30 a.m. a 4:00 p.m. hora del Este. En este estudio realizaremos un predicción del promedio mensual del **precio de cierre** de las acciones de la empresa farmaceutica Pfizer utilizando los datos extraídos de [Kaggle](https://www.kaggle.com/kannan1314/pfizer-stock-price-all-time)
los cuales también se puede observar en tiempo real en [finance yahoo](https://finance.yahoo.com/quote/PFE/). Estudiaremos tres diferentes modelos, en donde el primero será generado a partir de la función <code>auto.sarima>/code> del paquete **bayesforecast** luego tomando como referencia el comportamiento y resultados obtenidos del primer modelo se propondrán los siguientes dos modelos esto con el fin de ir mejorando y optmizando las predicciones hasta obtener una precisión factible en el resultado final.

```{r, message=FALSE}
library(forecast)
library(dplyr)
library(ggplot2)
library(bayesforecast)
library(cowplot)
library(loo)
library(bayesplot)
library(MLmetrics)
options(mc.cores = parallel::detectCores())
```

# Visualización de los datos

El conjunto de datos muestra cada uno de los indicadores necesarios para llevar acabo un control y análisis de los precios de las acciones en el mercado de la empresa Pfizer desde junio de 1972 hasta septiembre del 2021.

```{r, message=FALSE}
datos <- read.csv("C:/Users/Andres Dala/Desktop/Prueba 2/Pfizer.csv")
head(datos)
```

Nos centraremos en el precio de cierre (Close) desde el año 2010 haciendo un promedio mensual de las observaciones, de esta manera la serie de tiempo con que trabajaremos tendrá una frecuencia mensual.

```{r}
stock <- datos %>%
  select(Date,Close) %>%
  mutate(Date = as.Date(Date)) %>%
  filter(as.numeric(format(Date,"%Y")) >= 2010)

stock$month = lubridate::month(stock$Date)
stock$year = lubridate::year(stock$Date)

stock<- stock %>%
  group_by(year,month) %>%
  summarize(Stock_Mean = mean(Close)) %>%
  as.data.frame()

serie<-ts(stock$Stock_Mean, frequency = 12, start = 2010)
head(serie)
```

```{r, message=FALSE}
autoplot(serie) + stat_smooth(method = "lm") + 
  labs(x= "Años", y ="Precio de cierre promedio mensual")
```

Al graficar los datos podemos observar una clara tendencia creciente, de esta manera una opción viable para ajustar un modelo es utilizando **Regresión con errores ARIMA**, para una mayor compresión del mismo se recomienda leer : [Dynamic regression. models](https://otexts.com/fpp2/dynamic.html) Dada la naturaleza del estudio y por fines prácticos solamente tendremos en cuenta la información del conjunto de datos, por consiguiente los modelos a proponer tendrán la forma:

$$ y_t = \beta_0+\beta_1x_t+\eta_t$$

donde $\eta_t$ es un modelo $SARIMA(p,d,q)\times(P,D,Q)$ Bayesiano.
Ahora tomaremos el 95% de los datos como el conjunto de entrenamiento el cual de aqui en adelante llamaremos datos y el 5% de ellos será el conjunto de prueba el cual usaremos para la comparación de los modelos.

```{r}
train = head(serie, round(length(serie) * 0.95))
h = length(serie) - length(train)
test = tail(serie, h)
```

# Modelo 1

## Selección y ajuste del modelo

Iniciamos calculando el primer modelo con la función <code>auto.sarima</code> 

```{r}
sf1 <- auto.sarima(train,  xreg = as.matrix(1:134, nrow = 134))

prior_summary(sf1)
```

Como podemos observar la función propone un modelo AR(1) para los errores con sus respectivas distribuciones a priori para cada uno de los parámetros.

## Evaluación de la inferencia

```{r}
sf1
```



```{r,fig.height=10}
sf1Pars = data.frame(extract_stan(sf1,pars = c("mu0","sigma0","ar","breg")))
sf1Pars = cbind(Chain = sort(rep(1:4,1000)),sf1Pars)

mcmc_combo(sf1Pars)
```

## Diagnóstico del modelo

```{r}
check_residuals(sf1)
```

```{r}
Residuals1 = predictive_error(sf1)
Residuals1 = Residuals1[1:100,]

ppc_dens_overlay(y = rnorm(134),yrep = data.matrix(Residuals1))
```

```{r}
autoplot(sf1)+labs(title = "Verificación Predictiva Posteriori", y="Precio de cierre promedio")
```

# Modelo 2

## Selección del modelo



## Ajuste del modelo

```{r}
sf2 <- stan_sarima(train, order = c(1,1,0), xreg = as.matrix(1:134, nrow = 134))
```

```{r}
sf2
```

## Evaluación de la inferencia

```{r,fig.height=10}
sf2Pars = data.frame(extract_stan(sf2, pars = c("mu0","sigma0","ar","breg")))
sf2Pars = cbind(Chain = sort(rep(1:4,1000)),sf2Pars)

mcmc_combo(sf2Pars)
```

## Diagnóstico del modelo

```{r}
check_residuals(sf2)
```

```{r}
Residuals2 = predictive_error(sf2)
Residuals2 = Residuals2[1:100,]

ppc_dens_overlay(y = rnorm(134), yrep = data.matrix(Residuals2))
```

```{r}
autoplot(sf2) + labs(title = "Verificación Predictiva Posteriori", y = "Precio de cierre promedio")
```

# Modelo 3

## Selección del modelo

## Ajuste del modelo

```{r}
sf3 <- stan_sarima(train, order = c(1,1,0), seasonal = c(1,0,0), xreg =as.matrix(1:134, nrow = 134))
```

```{r}
prior_summary(sf3)
```

## Evaluación de la inferencia

```{r}
sf3
```

```{r,fig.height=10}
sf3Pars = data.frame(extract_stan(sf3, pars = c("mu0","sigma0","ar","sar","breg")))
sf3Pars = cbind(Chain = sort(rep(1:4,1000)),sf3Pars)

mcmc_combo(sf3Pars)
```

## Diagnóstico del modelo

```{r}
check_residuals(sf3)
```


```{r}
Residuals3 = predictive_error(sf3)
Residuals3 = Residuals3[1:100,]

ppc_dens_overlay(y = rnorm(134), yrep = data.matrix(Residuals3))
```

```{r}
autoplot(sf3) + labs(title = "Verificación Predictiva Posteriori", y = "Precio de cierre promedio")
```

# Comparación de modelos

```{r}
forecast1 <- forecast(object =  sf1, h = 7, xreg = matrix(134+1:7, ncol = 1))
pred <- ts(forecast1$mean, frequency = 12, start = c(2021,3))
forecast2 <- forecast(object =  sf2, h= 7, xreg = matrix(134+1:7, ncol = 1))
pred2 <- ts(forecast2$mean, frequency = 12, start = c(2021,3))
forecast3 <- forecast(object =  sf3, h = 7, xreg = matrix(134+1:7, ncol = 1))
pred3 <- ts(forecast3$mean, frequency = 12, start = c(2021,3))

co<-data.frame("Modelo 3" = pred, "Modelo 2" = pred2, 
               "Modelo 1" = pred3, "C Prueba" = test)

comb<-ts(co, frequency = 12, start = c(2021,3))

autoplot(comb[,c("Modelo.1", "Modelo.2","Modelo.3", "C.Prueba")]) +
  ylab("Precio de cierre mensual promedio") + xlab("Años") 

```

```{r, warning=FALSE}
train2<-ts(train[-1], frequency = 12, start = c(1980,2))
sf1<-stan_sarima(train2, order = c(1,0,0), xreg = as.matrix(1:133, ncol = 1))
loo1 <- loo(sf1)
loo2 <- loo(sf2)
loo3 <- loo(sf3)

loo_compare(loo1,loo2,loo3)
```

# Predicción Final

```{r}
sf4<-stan_sarima(serie, order = c(1,1,0), seasonal = c(1,0,0), xreg = as.matrix(1:141, ncol = 1))
forecast4<-forecast(object =  sf4, h = 5, xreg = matrix(141+1:5, ncol = 1))

autoplot(forecast4) + labs(title = "Predicción final", y = "Precio de cierre mensual promedio",
                            x = "Años")  + xlim(2019,2023) 
```



